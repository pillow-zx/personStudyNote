### 一. 系统的硬件组成
![[Pasted image 20250319224400.png]]
#### 1.总线
贯穿整个系统的是一组电子管道，称作**总线**，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字（word）。字中的字节数（即字长）是一个基本的系统参数，各个系统中都不尽相同。现在的大多数机器字长要么是 4 个字节（32 位），要么是 8 个字节（64 位）。

#### 2.I/O设备
I/O（输入/输出）设备是系统与外部世界的联系通道。每个 I/O 设备都通过一个**控制器**或**适配器**与 I/O 总线相连。控制器和适配器之间的区别主要在于它们的封装方式。控制器是 I/O 设备本身或者系统的主印制电路板（通常称作主板）上的芯片组。而适配器则是一块插在主板插槽上的卡。无论如何，它们的功能都是在 I/O 总线和 I/O 设备之间传递信息。

#### 3.主存（内存）
**主存**是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组**动态随机存取存储器**（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。

#### 4.处理器
**中央处理单元**（CPU），简称**处理器**，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或**寄存器**），称为**程序计数器**（PC）。在任何时刻，PC 都指向主存中的某条机器语言指令（即含有该条指令的地址）。寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU 计算新的数据和地址值。
下面是一些简单操作的例子，CPU 在指令的要求下可能会执行这些操作。
- **加载**：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。
  
- **存储**：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原 来的内容。
  
- **操作**：把两个寄存器的内容复制到 ALU，ALU 对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。
  
- **跳转**：从指令本身中抽取一个字，并将这个字复制到程序计数器（PC）中，以覆盖 PC 中原来的值。

我们将处理器的指令集架构和处理器的**微体系结构**区分开来：指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的。

### 二.可执行文件的产生

以一份c语言的hello程序为例：
```c
#include <stdio.h>

int main() {
	printf("hello, world\n");
	return 0;
}
```

一份代码源文件变成一份可执行文件开始到结束要经历
	(1).预处理. 
	(2).编译. 
	(3).汇编. 
	(4).链接
![[Pasted image 20250319225759.png]]


**1.预处理阶段：预处理器（cpp）根据以字符 # 开头的命令，修改原始的 C 程序。比如 hello.c 中第 1 行的`#include <stdio.h>`命令告诉预处理器读取系统头文件 stdio.h 的内容，并把它直接插入程序文本中。结果就得到了另一个 C 程序，通常是以 .i 作为文件扩展名。
**命令为：

```bash
gcc -E hello.c
```


**2.编译阶段。编译器（cc1）将文本文件 hello.i 翻译成文本文件 hello.s，它包含一个汇编语言程序**。该程序包含函数 main 的定义，如下所示∶

```
main:
    subq $8, %rsp
    movl $.LC0, %edi
    call puts
    movl $0, %eax
    addq $8, %rsp
    ret
```

**命令为**：

```bash
gcc -S hello.i
```

**3.汇编阶段。接下来，汇编器（as）将 hello.s 翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序**（relocatable object program）的格式，并将结果保存在目标文件 hello.o 中。
**命令为**：

```bash
gcc -c hello.s
```
**4.链接阶段。请注意，hello 程序调用了 printf 函数，它是每个 C 编译器都提供的标准 C 库中的一个函数。printf 函数存在于一个名为 printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的 hello.o 程序中。链接器（ld）就负责处理这种合并。结果就得到 hello 文件，它是一个可执行目标文件**（或者简称为**可执行文件**），可以被加载到内存中，由系统执行

### 三.运行可执行文件

**1.初始时，shell 程序执行它的指令，等待我们输人一个命令。当我们在键盘上输人字符串 “./hello” 后，shell 程序将字符逐一读入寄存器，再把它存放到内存中**
![[Pasted image 20250319230543.png]]
当我们在键盘上敲回车键时，shell 程序就知道我们已经结束了命令的输入。然后 shell 执行一系列指令来加载可执行的 hello 文件，这些指令将 hello 目标文件中的代码和数据从磁盘复制到主存。数据包括最终会被输出的字符串 “hello, world\n”。

**需要注意的是，在输入./hello的过程中是不会输入主存的，只有回车键敲下之后才会将hello输入主存**

**2.利用直接存储器存取（DMA）技术，数据可以不通过处理器而直接从磁盘到达主存。**
![[Pasted image 20250319231047.png]]**3.一旦目标文件 hello 中的代码和数据被加载到主存，处理器就开始执行 hello 程序的 main 程序中的机器语言指令。这些指令将 “hello, world\n” 字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上**

![[Pasted image 20250319231111.png]]
#### 4.存储设备的层次结构

根据机械原理，较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高于同类的低速设备。具体来说，一个典型的寄存器文件只存储几百字节的信息，而主存里可存放几十亿字节。然而，处理器从寄存器文件中读数据比从主存中读取几乎要快 100 倍。一个典型的寄存器文件只存储几百字节的信息，而主存里可存放几十亿字节。然而，处理器从寄存器文件中读数据比从主存中读取几乎要快 100 倍。

可以看到在一个程序的生命周期中需要经过许多步骤，每一步都需要消耗大量时间，想要尽可能缩短时间，就需要从数据处理速度和数据传输速度下手。为了尽可能加快数据传输速度，高速缓存应运而生。

高速缓存的传输速度远高于主存，可以把常用的一些数据存到告诉缓存中，在需要时可以快速调用。

**高速缓存常见的最高有三级：L1缓存， L2缓存和L3缓存。**

![[Pasted image 20250319231626.png]]

实际上，每个计算机系统中的存储设备都被组织成了一个**存储器层次结构**

在这个层次结构中，从上至下，设备的访问速度越来越慢、容量越来越大，并且每字节的造价也越来越便宜。寄存器文件在层次结构中位于最顶部，也就是第 0 级或记为 L0。

![[Pasted image 20250319231734.png]]

存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。因此，寄存器文件就是 L1 的高速缓存，L1 是 L2 的高速缓存，L2 是 L3 的高速缓存，L3 是主存的高速缓存，而主存又是磁盘的高速缓存。在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存。

### 三. 操作系统管理硬件


#### 1. 操作系统概述
操作系统整体上处于程序与硬件之间，是软硬件之间沟通的桥梁。
![[Pasted image 20250319232846.png]]

操作系统有两个基本功能∶（1）防止硬件被失控的应用程序滥用；（2）向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。操作系统通过几个基本的抽象概念（**进程**、**虚拟内存**和**文件**）来实现这两个功能。文件是对 I/O 设备的抽象表示，虚拟内存是对主存和磁盘 I/O 设备的抽象表示，进程则是对处理器、主存和 I/O 设备的抽象表示。
![[Pasted image 20250319232834.png]]
#### 2.进程与线程

**进程**是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。而**并发运行**，则是说一个进程的指令和另一个进程的指令是交错执行的。无论是在单核还是多核系统中，一个 CPU 看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种交错执行的机制称为**上下文切换**。操作系统保持跟踪进程运行所需的所有状态信息。在任何一个时刻，单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。

![[Pasted image 20250319233242.png]]
从一个进程到另一个进程的转换是由操作系统**内核**（kernel）管理的。内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，它就执行一条特殊的**系统调用**（system call）指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。

**注意：内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。

在现代系统中，一个进程可以由多个称为**线程**的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。

#### 3.虚拟内存

可以由多个称为**线程**的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。
![[Pasted image 20250319233439.png]]每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。
- **程序代码和数据**。对所有的进程来说，代码是从同一固定地址开始，紧接着的是和 C 全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的，在示例中就是可执行文件 hello。在第 7 章我们研究链接和加载时，你会学习更多有关地址空间的内容。
  
- **堆**：代码和数据区后紧随着的是运行时堆。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像 malloc 和 free 这样的 C 标准库函数时，堆可以在运行时动态地扩展和收缩。
  
- **共享库**：大约在地址空间的中间部分是一块用来存放像 C 标准库和数学库这样的共享库的代码和数据的区域。共享库的概念非常强大，也相当难懂。
  
- **栈**：位于用户虚拟地址空间顶部的是**用户栈**，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别地，每次我们调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩。在第 3 章中将学习编译器是如何使用栈的。
  
- **内核虚拟内存**：地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。

#### 4.文件
**文件**就是字节序列，仅此而已。每个I/O设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件。系统中的所有输入输出都是通过使用一小组称为 Unix I/O 的系统函数调用读写文件来实现的。

### 四. 系统之间利用网络通信

以hello程序为例展示网络通信：

![[Pasted image 20250319233941.png]]假设用本地主机上的 telnet 客户端连接远程主机上的 telnet 服务器。在我们登录到远程主机并运行 shell 后，远端的 shell 就在等待接收输入命令。当我们在 telnet 客户端键入 “hello” 字符串并敲下回车键后，客户端软件就会将这个字符串发送到 telnet 的服务器。telnet 服务器从网络上接收到这个字符串后，会把它传递给远端 shell 程序。接下来，远端 shell 运行 hello 程序，并将输出行返回给 telnet 服务器。最后，telnet 服务器通过网络把输出串转发给 telnet 客户端，客户端就将输出串输出到我们的本地终端上。

### 五. Amdahl 定律

Amdahl 定律（Amdahl's law）的主要思想是，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。

若系统执行某应用程序需要时间为ToldTold​ 。假设系统某部分所需执行时间与该时间的比例为 αα ，而该部分性能提升比例为 kk 。即该部分初始所需时间为 αToldαTold​ ，现在所需时间为 (αTold)/k(αTold​)/k 。因此，总的执行时间应为

$$
Tnew​=(1−α)Told​+(αTold​)/k=Told​[(1−α)+α/k]
$$

由此，可以计算加速比 S=Told/TnewS=Told​/Tnew​ 为

$$
S=(1−α)+α/k1​
$$

### 六.并行和并发

**并发**（concurrency）是一个通用的概念，指一个同时具有多个活动的系统。
**并行**（parallelism）指的是用并发来使一个系统运行得更快。

#### 1.线程级并发
构建在进程这个抽象之上，我们能够设计出同时有多个程序执行的系统，这就导致了并发。使用线程，我们甚至能够在一个进程中执行多个控制流。自 20 世纪 60 年代初期出现时间共享以来，计算机系统中就开始有了对并发执行的支持。传统意义上，这种并发执行只是模拟出来的，是通过使一台计算机在它正在执行的进程间快速切换来实现的。这种并发形式允许多个用户同时与系统交互，例如，当许多人想要从一个 Web 服务器获取页面时。它还允许一个用户同时从事多个任务，例如，在一个窗口中开启 Web 浏览器，在另一窗口中运行字处理器，同时又播放音乐。在以前，即使处理器必须在多个任务间切换，大多数实际的计算也都是由一个处理器来完成的。这种配置称为**单处理器系统**。

当构建一个由单操作系统内核控制的多处理器组成的系统时，我们就得到了一个**多处理器系统**。其实从 20 世纪 80 年代开始，在大规模的计算中就有了这种系统，但是直到最近，随着多核处理器和**超线程**（hyperthreading）的出现，这种系统才变得常见。

![[Pasted image 20250319234758.png]]

多核处理器是将多个 CPU（称为“核”）集成到一个集成电路芯片上。
![[Pasted image 20250319234927.png]]
超线程，有时称为**同时多线程**（simultaneous multi-threading），是一项允许一个 CPU 执行多个控制流的技术。它涉及 CPU 某些硬件有多个备份，比如程序计数器和寄存器文件，而其他的硬件部分只有一份，比如执行浮点算术运算的单元。

多处理器的使用可以从两方面提高系统性能。首先，它减少了在执行多个任务时模拟并发的需要,其次，它可以使应用程序运行得更快。

#### 2. 指令级并行

在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行。如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为**超标量**（super-scalar）处理器。大多数现代处理器都支持超标量操作。

#### 3. 单指令、多数据并行

在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即 SIMD 并行。在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即 SIMD 并行。


### 七. 计算机系统的抽象模型

抽象的使用是计算机科学中最为重要的概念之一。

![[Pasted image 20250319235228.png]]

**文件**是对 I/O 设备的抽象，**虚拟内存**是对程序存储器的抽象，**进程**是对一个正在运行的程序的抽象，**虚拟机**提供对整个计算机的抽象，包括操作系统、处理器和程序。

**视频讲解参见**：[https://www.bilibili.com/video/BV1cD4y1D7uR/]()